"""
    写像12相のどのパターンになるか
    https://qiita.com/drken/items/f2ea4b58b0d21621bd51

    玉n個、箱k個を用意して、箱に玉を入れる問題を考えたときに、
    玉: 区別するorしない
    箱: 区別するorしない
    個数: 1個以内 or 制限なし or １個以上

    のそれぞれの組み合わせに分類できる。

    さまざまな数え上げ問題をこの玉と箱の問題で抽象化して考えると、
    この12パターンの求め方をしっておくことで応用ができるようになる。
"""

def pattern01(n, k):
    """
        玉(n): 区別する
        箱(k): 区別する
        個数: 1個以内(= 0 or 1個)

        上記条件から、箱のほうが多い、すなわちn ≤ k
        ボールを番号順に箱に入れていったときの、箱番号の順列のパターン数
    """
    if n > k:
        return 0
    
    from math import perm
    return perm(k, n)

def pattern02(n, k):
    """
        玉(n): 区別しない
        箱(k): 区別する
        個数: 1個以内(= 0 or 1個)

        上記条件から、箱のほうが多い、すなわちn ≤ k
        単純に箱k個から、玉を入れる箱n個の組み合わせになる
    """
    if n > k:
        return 0
    
    from math import comb
    return comb(k, n)


def pattern4(n, k):
    """
        玉(n): 区別する
        箱(k): 区別しない
        個数: 1個以内(= 0 or 1個)

        この場合、ボールのほうが多ければ不可能。
        箱が区別されない、かつ、すべての玉はどれかの箱に単独で入ることになるため、
        この条件は1通りしかない
    """
    if n > k:
        return 0

    return 1

def pattern05(n, k):
    """
        玉(n): 区別しない
        箱(k): 区別しない
        個数: 1個以内(= 0 or 1個)

        この場合、ボールのほうが多ければ不可能。
        すべての玉は箱に単独で入っている状態の１通りしか存在しない
    """
    if n > k:
        return 0

    return 1
    
def pattern06(n, k):
    """
        玉(n): 区別しない
        箱(k): 区別する
        個数: 制限なし(0個以上)

        すなわち、「どの箱に何個ボールが入るか」ということ。
        これは「重複組合せ（ボールと仕切りの位置関係の問題）」と考えられる
    """
    from math import comb
    return comb(n+k-1, n)

def pattern07(n, k):
    """
        玉(n): 区別しない
        箱(k): 区別する
        個数: 1個以上

        0個の箱は許容しない(必ずn ≥ kとなる)
        玉を区別しないので、すべての箱に玉を1個ずつ入れたあと、重複組合せで考えればいい
    """
    from math import comb
    return comb(n-1, k-1)

def pattern08(n, k):
    """
        玉(n): 区別する
        箱(k): 区別する
        個数: 1個以上

        箱1は玉1個以上かつ箱2は玉1個以上かつ...、となるので、この余事象を考える。
        つまり、箱1に玉0個または箱2に玉0個または...、となる。

        この考え方をベースにして、包除原理で求める。
    """
    from math import comb
    ans = 0
    for i in range(k + 1):
        ans += pow(-1, k-i) * comb(k, i) * pow(i, n)
    return ans

def pattern09(n, k, r=1):
    """
        玉(n): 区別する
        箱(k): 区別しない
        個数: 1個以上

        玉をグループに分けるイメージ
        pattern08と箱の区別の有無が違うだけなので、k!で割れば求まる。

        この数を「スターリング数」と呼び、漸化式が存在するので、
        DPを使用して求めることができる。

        漸化式:
            S(n, k) = S(n-1, k-1) + kS(n-1, k)
        
        もっと一般化して、「r個以上」に対応した漸化式は、以下のようになる。
        
        漸化式:
            S'(n, k) = (n-1)C(r-1)S'(n-r, k-1) + kS'(n-1, k)
        
        また、n個すべてをグループに振り分けず、何個か選んでkグループ作る場合は、
        以下の漸化式の通りとなる。

        漸化式:
            S'(n, k) 0 S'(n-1, k-1) + (k+1)S'(n-1, k)
    """
    pass

